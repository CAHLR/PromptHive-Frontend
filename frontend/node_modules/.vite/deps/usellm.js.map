{
  "version": 3,
  "sources": ["../../usellm/dist/esm/server/eventsource-parser.js", "../../usellm/dist/esm/shared/utils.js", "../../usellm/dist/esm/server/OpenAIStream.js", "../../usellm/dist/esm/server/llm-service.js", "../../usellm/dist/esm/client/usellm.js", "../../usellm/dist/esm/client/llm-provider.js", "../../usellm/dist/esm/index.js"],
  "sourcesContent": ["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse) {\n    // Processing state\n    let isFirstChunk;\n    let buffer;\n    let startingPosition;\n    let startingFieldLength;\n    // Event state\n    let eventId;\n    let eventName;\n    let data;\n    reset();\n    return { feed, reset };\n    function reset() {\n        isFirstChunk = true;\n        buffer = \"\";\n        startingPosition = 0;\n        startingFieldLength = -1;\n        eventId = undefined;\n        eventName = undefined;\n        data = \"\";\n    }\n    function feed(chunk) {\n        buffer = buffer ? buffer + chunk : chunk;\n        // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n        // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n        // always decoded as UTF8 as per the specification.\n        if (isFirstChunk && hasBom(buffer)) {\n            buffer = buffer.slice(BOM.length);\n        }\n        isFirstChunk = false;\n        // Set up chunk-specific processing state\n        const length = buffer.length;\n        let position = 0;\n        let discardTrailingNewline = false;\n        // Read the current buffer byte by byte\n        while (position < length) {\n            // EventSource allows for carriage return + line feed, which means we\n            // need to ignore a linefeed character if the previous character was a\n            // carriage return\n            // @todo refactor to reduce nesting, consider checking previous byte?\n            // @todo but consider multiple chunks etc\n            if (discardTrailingNewline) {\n                if (buffer[position] === \"\\n\") {\n                    ++position;\n                }\n                discardTrailingNewline = false;\n            }\n            let lineLength = -1;\n            let fieldLength = startingFieldLength;\n            let character;\n            for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n                character = buffer[index] || \"\";\n                if (character === \":\" && fieldLength < 0) {\n                    fieldLength = index - position;\n                }\n                else if (character === \"\\r\") {\n                    discardTrailingNewline = true;\n                    lineLength = index - position;\n                }\n                else if (character === \"\\n\") {\n                    lineLength = index - position;\n                }\n            }\n            if (lineLength < 0) {\n                startingPosition = length - position;\n                startingFieldLength = fieldLength;\n                break;\n            }\n            else {\n                startingPosition = 0;\n                startingFieldLength = -1;\n            }\n            parseEventStreamLine(buffer, position, fieldLength, lineLength);\n            position += lineLength + 1;\n        }\n        if (position === length) {\n            // If we consumed the entire buffer to read the event, reset the buffer\n            buffer = \"\";\n        }\n        else if (position > 0) {\n            // If there are bytes left to process, set the buffer to the unprocessed\n            // portion of the buffer only\n            buffer = buffer.slice(position);\n        }\n    }\n    function parseEventStreamLine(lineBuffer, index, fieldLength, lineLength) {\n        if (lineLength === 0) {\n            // We reached the last line of this event\n            if (data.length > 0) {\n                onParse({\n                    type: \"event\",\n                    id: eventId,\n                    event: eventName || undefined,\n                    data: data.slice(0, -1), // remove trailing newline\n                });\n                data = \"\";\n                eventId = undefined;\n            }\n            eventName = undefined;\n            return;\n        }\n        const noValue = fieldLength < 0;\n        const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength));\n        let step = 0;\n        if (noValue) {\n            step = lineLength;\n        }\n        else if (lineBuffer[index + fieldLength + 1] === \" \") {\n            step = fieldLength + 2;\n        }\n        else {\n            step = fieldLength + 1;\n        }\n        const position = index + step;\n        const valueLength = lineLength - step;\n        const value = lineBuffer.slice(position, position + valueLength).toString();\n        if (field === \"data\") {\n            data += value ? `${value}\\n` : \"\\n\";\n        }\n        else if (field === \"event\") {\n            eventName = value;\n        }\n        else if (field === \"id\" && !value.includes(\"\\u0000\")) {\n            eventId = value;\n        }\n        else if (field === \"retry\") {\n            const retry = parseInt(value, 10);\n            if (!Number.isNaN(retry)) {\n                onParse({ type: \"reconnect-interval\", value: retry });\n            }\n        }\n    }\n}\nconst BOM = [239, 187, 191];\nfunction hasBom(buffer) {\n    return BOM.every((charCode, index) => buffer.charCodeAt(index) === charCode);\n}\n", "export const CHAT_COMPLETIONS_API_URL = \"https://api.openai.com/v1/chat/completions\";\nexport const AUDIO_TRANSCRIPTIONS_API_URL = \"https://api.openai.com/v1/audio/transcriptions\";\nexport const EMBEDDINGS_API_URL = \"https://api.openai.com/v1/embeddings\";\nexport const getTextToSpeechApiUrl = (voice_id) => `https://api.elevenlabs.io/v1/text-to-speech/${voice_id}`;\nexport const ELVEN_LABS_DEFAULT_MODEL_ID = \"eleven_monolingual_v1\";\nexport const ELVEN_LABS_DEFAULT_VOICE_ID = \"21m00Tcm4TlvDq8ikWAM\";\nexport const IMAGE_GENERATION_API_URL = \"https://api.openai.com/v1/images/generations\";\nexport const REPLICATE_API_URL = \"https://api.replicate.com/v1/predictions\";\nexport const HUGGING_FACE_API_URL = \"https://api-inference.huggingface.co/models/\";\nexport const EDIT_IMAGE_API_URL = \"https://api.openai.com/v1/images/edits\";\nexport const IMAGE_VARIATIONS_API_URL = \"https://api.openai.com/v1/images/variations\";\nexport class ResponseError extends Error {\n    constructor() {\n        super(...arguments);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n}\nexport function makeErrorResponse(message, status) {\n    const error = new ResponseError(JSON.stringify({ message }));\n    error.status = status || 500;\n    return error;\n}\nexport async function streamOpenAIResponse(response, callback) {\n    if (!response.body) {\n        throw Error(\"Response has no body\");\n    }\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let done = false;\n    let text = \"\";\n    let isFirst = true;\n    while (!done) {\n        const { value, done: doneReading } = await reader.read();\n        done = doneReading;\n        const chunkValue = decoder.decode(value);\n        text += chunkValue;\n        const message = { content: text, role: \"assistant\" };\n        callback && callback({ message, isFirst, isLast: done });\n        isFirst = false;\n    }\n    const message = { content: text, role: \"assistant\" };\n    return { message };\n}\nexport function fillPrompt(str, data = {}) {\n    return Object.entries(data).reduce((res, [key, value]) => {\n        // lookbehind expression, only replaces if mustache was not preceded by a backslash\n        const mainRe = new RegExp(`(?<!\\\\\\\\){{\\\\s*${key}\\\\s*}}`, \"g\");\n        // this regex is actually (?<!\\\\){{\\s*<key>\\s*}} but because of escaping it looks like that...\n        const escapeRe = new RegExp(`\\\\\\\\({{\\\\s*${key}\\\\s*}})`, \"g\");\n        // the second regex now handles the cases that were skipped in the first case.\n        return res.replace(mainRe, value.toString()).replace(escapeRe, \"$1\");\n    }, str);\n}\nexport function dataURLToBlob(dataurl) {\n    var _a;\n    let arr = dataurl.split(\",\");\n    if (!arr || arr.length < 2) {\n        throw new Error(\"Invalid data URL\");\n    }\n    let mimeMatch = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.match(/:(.*?);/);\n    if (!mimeMatch || !arr[1]) {\n        throw new Error(\"Invalid data URL\");\n    }\n    let mime = mimeMatch[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], { type: mime });\n}\nexport function dataUrlToExtension(dataURL) {\n    var extension = \"\";\n    if (dataURL.indexOf(\"/\") !== -1 && dataURL.indexOf(\";\") !== -1) {\n        var startIndex = dataURL.indexOf(\"/\") + 1;\n        var endIndex = dataURL.indexOf(\";\");\n        extension = dataURL.substring(startIndex, endIndex);\n    }\n    return extension;\n}\nfunction dotProduct(vecA, vecB) {\n    let product = 0;\n    if (vecA.length !== vecB.length)\n        throw new Error(\"Vectors must be same length\");\n    for (let i = 0; i < vecA.length; i++) {\n        product += vecA[i] * vecB[i];\n    }\n    return product;\n}\nfunction magnitude(vec) {\n    let sum = 0;\n    for (let i = 0; i < vec.length; i++) {\n        sum += vec[i] * vec[i];\n    }\n    return Math.sqrt(sum);\n}\nexport function cosineSimilarity(vecA, vecB) {\n    return dotProduct(vecA, vecB) / (magnitude(vecA) * magnitude(vecB));\n}\nexport function scoreEmbeddings(options) {\n    const { embeddings, query, top } = options;\n    const scores = embeddings.map((vector) => cosineSimilarity(query, vector));\n    const sortedScores = scores\n        .map((score, index) => ({ score, index }))\n        .sort((a, b) => b.score - a.score)\n        .slice(0, top || undefined);\n    return sortedScores;\n}\n", "var __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nimport { createParser, } from \"./eventsource-parser\";\nimport { CHAT_COMPLETIONS_API_URL } from \"../shared/utils\";\nexport default async function OpenAIStream(options) {\n    const { body, openaiApiKey, fetcher = fetch } = options;\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    const res = await fetcher(CHAT_COMPLETIONS_API_URL, {\n        headers: {\n            \"Content-Type\": \"application/json\",\n            Authorization: `Bearer ${openaiApiKey}`,\n        },\n        method: \"POST\",\n        body: JSON.stringify(body),\n    });\n    if (res.status != 200 || !res.body) {\n        throw new Error(await res.text());\n    }\n    const stream = new ReadableStream({\n        async start(controller) {\n            var _a, e_1, _b, _c;\n            const onParse = (event) => {\n                if (event.type === \"event\") {\n                    const data = event.data;\n                    if (data === \"[DONE]\") {\n                        controller.close();\n                        return;\n                    }\n                    try {\n                        const json = JSON.parse(data);\n                        const text = json.choices[0].delta.content;\n                        const queue = encoder.encode(text);\n                        controller.enqueue(queue);\n                    }\n                    catch (e) {\n                        controller.error(e);\n                    }\n                }\n            };\n            const parser = createParser(onParse);\n            if (res.body) {\n                try {\n                    for (var _d = true, _e = __asyncValues(res.body), _f; _f = await _e.next(), _a = _f.done, !_a;) {\n                        _c = _f.value;\n                        _d = false;\n                        try {\n                            const chunk = _c;\n                            parser.feed(decoder.decode(chunk));\n                        }\n                        finally {\n                            _d = true;\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }\n        },\n    });\n    return stream;\n}\n", "var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport OpenAIStream from \"./OpenAIStream\";\nimport { AUDIO_TRANSCRIPTIONS_API_URL, CHAT_COMPLETIONS_API_URL, EDIT_IMAGE_API_URL, REPLICATE_API_URL, HUGGING_FACE_API_URL, ELVEN_LABS_DEFAULT_MODEL_ID, ELVEN_LABS_DEFAULT_VOICE_ID, EMBEDDINGS_API_URL, IMAGE_GENERATION_API_URL, IMAGE_VARIATIONS_API_URL, cosineSimilarity, dataURLToBlob, dataUrlToExtension, fillPrompt, getTextToSpeechApiUrl, makeErrorResponse, scoreEmbeddings, } from \"../shared/utils\";\nconst defaultTemplate = {\n    model: \"gpt-3.5-turbo\",\n    max_tokens: 1000,\n    temperature: 0.8,\n};\nexport class LLMService {\n    constructor({ openaiApiKey = \"\", elvenLabsApiKey = \"\", replicateApiKey = \"\", huggingFaceApiKey = \"\", fetcher = fetch, templates = {}, debug = false, isAllowed = () => true, actions = [], }) {\n        Object.defineProperty(this, \"templates\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"openaiApiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"elvenLabsApiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicateApiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"huggingFaceApiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetcher\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"actions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"isAllowed\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"customActions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"cosineSimilarity\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: cosineSimilarity\n        });\n        Object.defineProperty(this, \"scoreEmbeddings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: scoreEmbeddings\n        });\n        this.openaiApiKey = openaiApiKey;\n        this.elvenLabsApiKey = elvenLabsApiKey;\n        this.replicateApiKey = replicateApiKey;\n        this.huggingFaceApiKey = huggingFaceApiKey;\n        this.fetcher = fetcher;\n        this.templates = templates;\n        this.debug = debug;\n        this.isAllowed = isAllowed;\n        this.actions = actions;\n    }\n    registerTemplate(template) {\n        this.templates[template.id] = template;\n    }\n    registerAction(id, action) {\n        this.customActions[id] = action;\n    }\n    async callAction(action, body = {}) {\n        if (!this.actions.includes(action) && !this.customActions[action]) {\n            throw makeErrorResponse(`Action \"${action}\" is not allowed`, 400);\n        }\n        if (action === \"chat\") {\n            return this.chat(body);\n        }\n        if (action === \"transcribe\") {\n            return this.transcribe(body);\n        }\n        if (action === \"embed\") {\n            return this.embed(body);\n        }\n        if (action === \"speak\") {\n            return this.speak(body);\n        }\n        if (action === \"generateImage\") {\n            return this.generateImage(body);\n        }\n        if (action === \"editImage\") {\n            return this.editImage(body);\n        }\n        if (action === \"imageVariation\") {\n            return this.imageVariation(body);\n        }\n        if (action === \"voiceChat\") {\n            return this.voiceChat(body);\n        }\n        if (action === \"callReplicate\") {\n            return this.callReplicate(body);\n        }\n        if (action === \"callHuggingFace\") {\n            return this.callHuggingFace(body);\n        }\n        const actionFunc = this.customActions[action];\n        if (!actionFunc) {\n            throw makeErrorResponse(`Action \"${action}\" is not supported`, 400);\n        }\n        return actionFunc(body);\n    }\n    prepareChatBody(body) {\n        const template = Object.assign(Object.assign({}, defaultTemplate), (this.templates[body.template || \"\"] || {}));\n        let filledMessages = [];\n        if (template.systemPrompt) {\n            filledMessages.push({\n                role: \"system\",\n                content: fillPrompt(template.systemPrompt, body.inputs),\n            });\n        }\n        if (template.userPrompt) {\n            filledMessages.push({\n                role: \"user\",\n                content: fillPrompt(template.userPrompt, body.inputs),\n            });\n        }\n        if (body.messages) {\n            body.messages.forEach((message) => {\n                filledMessages.push({\n                    role: message.role,\n                    content: message.content,\n                    user: message.user,\n                });\n            });\n        }\n        if (filledMessages.length == 0) {\n            throw makeErrorResponse(\"Empty message list. Please provide at least one message!\", 400);\n        }\n        const preparedBody = {\n            messages: filledMessages,\n            stream: body.stream,\n            user: body.user,\n            model: template.model,\n            temperature: template.temperature,\n            top_p: template.top_p,\n            n: template.n,\n            max_tokens: template.max_tokens,\n            presence_penalty: template.presence_penalty,\n            frequency_penalty: template.frequency_penalty,\n            logit_bias: template.logit_bias,\n        };\n        return preparedBody;\n    }\n    async handle({ body = {}, request, }) {\n        if (!(await this.isAllowed({ body, request }))) {\n            throw makeErrorResponse(\"Request not allowed\", 405);\n        }\n        if (!this.openaiApiKey) {\n            throw makeErrorResponse(\"OpenAI API key is required.\", 400);\n        }\n        if (!(\"$action\" in body)) {\n            throw makeErrorResponse(\"`handle` expects a key $action in the body\", 400);\n        }\n        const { $action } = body, rest = __rest(body, [\"$action\"]);\n        const result = await this.callAction($action, rest);\n        if (\"stream\" in body && body.stream) {\n            return result;\n        }\n        return { result: JSON.stringify(result) };\n    }\n    async chat(body) {\n        const preparedBody = this.prepareChatBody(body);\n        if (this.debug) {\n            console.log(\"[LLMService] preparedBody\", preparedBody);\n        }\n        if (preparedBody.stream) {\n            const result = await OpenAIStream({\n                body: preparedBody,\n                openaiApiKey: this.openaiApiKey,\n                fetcher: this.fetcher,\n            });\n            return { result };\n        }\n        else {\n            const response = await this.fetcher(CHAT_COMPLETIONS_API_URL, {\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    Authorization: `Bearer ${this.openaiApiKey}`,\n                },\n                method: \"POST\",\n                body: JSON.stringify(preparedBody),\n            });\n            if (!response.ok) {\n                throw new Error(await response.text());\n            }\n            return response.json();\n        }\n    }\n    async embed(options) {\n        const { input, user } = options;\n        const model = \"text-embedding-ada-002\";\n        if (!input) {\n            throw makeErrorResponse(\"'input' is required\", 400);\n        }\n        if (typeof input !== \"string\" && !Array.isArray(input)) {\n            throw makeErrorResponse(\"'input' must be a string or a list of strings\", 400);\n        }\n        let santizedInput;\n        if (typeof input === \"string\") {\n            santizedInput = input.trim();\n        }\n        else {\n            santizedInput = input.map((s) => {\n                const trimmed = s.trim();\n                if (!trimmed) {\n                    throw makeErrorResponse(\"'input' must not contain any empty strings\");\n                }\n                return s.trim();\n            });\n        }\n        if (santizedInput.length === 0) {\n            throw makeErrorResponse(\"'input' must not be empty\", 400);\n        }\n        const response = await this.fetcher(EMBEDDINGS_API_URL, {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${this.openaiApiKey}`,\n            },\n            method: \"POST\",\n            body: JSON.stringify({ input, user, model }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const { data } = await response.json();\n        const embeddings = data.map((d) => d.embedding);\n        return { embeddings };\n    }\n    async transcribe(options) {\n        const { audioUrl, language, prompt } = options;\n        if (!audioUrl) {\n            throw makeErrorResponse(\"'audioUrl' is required\", 400);\n        }\n        const audioBlob = dataURLToBlob(audioUrl);\n        const formData = new FormData();\n        formData.append(\"file\", audioBlob, \"recording.wav\");\n        formData.append(\"model\", \"whisper-1\");\n        if (language) {\n            formData.append(\"language\", language);\n        }\n        if (prompt) {\n            formData.append(\"prompt\", prompt);\n        }\n        const response = await this.fetcher(AUDIO_TRANSCRIPTIONS_API_URL, {\n            method: \"POST\",\n            body: formData,\n            headers: {\n                Authorization: `Bearer ${this.openaiApiKey}`,\n            },\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async speak(options) {\n        const { text, model_id = ELVEN_LABS_DEFAULT_MODEL_ID, voice_id = ELVEN_LABS_DEFAULT_VOICE_ID, voice_settings, } = options;\n        const response = await this.fetcher(getTextToSpeechApiUrl(voice_id), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"xi-api-key\": this.elvenLabsApiKey,\n            },\n            body: JSON.stringify({\n                text,\n                model_id,\n                voice_settings,\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const responseBlob = await response.blob();\n        const responseBuffer = Buffer.from(await responseBlob.arrayBuffer());\n        const audioUrl = \"data:\" +\n            responseBlob.type +\n            \";base64,\" +\n            responseBuffer.toString(\"base64\");\n        return { audioUrl };\n    }\n    async generateImage(options) {\n        const { prompt, n = 1, size = \"256x256\" } = options;\n        if (!prompt) {\n            throw makeErrorResponse(\"'prompt' is required\", 400);\n        }\n        const response = await this.fetcher(IMAGE_GENERATION_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${this.openaiApiKey}`,\n            },\n            body: JSON.stringify({\n                prompt,\n                n: Math.min(n, 4),\n                size: size,\n                response_format: \"url\",\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const { data } = await response.json();\n        const images = data.map((d) => d.url || d.b64_json);\n        return { images };\n    }\n    async editImage(options) {\n        const { image, mask, prompt, n, size, user } = options;\n        const formData = new FormData();\n        formData.append(\"image\", dataURLToBlob(image), `image.${dataUrlToExtension(image)}`);\n        mask &&\n            formData.append(\"mask\", dataURLToBlob(mask), `mask.${dataUrlToExtension(mask)}`);\n        prompt && formData.append(\"prompt\", prompt);\n        n && formData.append(\"n\", Math.max(n, 4).toString());\n        size && formData.append(\"size\", size);\n        user && formData.append(\"user\", user);\n        const response = await this.fetcher(EDIT_IMAGE_API_URL, {\n            method: \"POST\",\n            body: formData,\n            headers: {\n                Authorization: `Bearer ${this.openaiApiKey}`,\n            },\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const { data } = await response.json();\n        const images = data.map((d) => d.url || d.b64_json);\n        return { images };\n    }\n    async imageVariation(options) {\n        const { image, n, size, user } = options;\n        const formData = new FormData();\n        formData.append(\"image\", dataURLToBlob(image), `image.${dataUrlToExtension(image)}`);\n        n && formData.append(\"n\", Math.max(n, 4).toString());\n        size && formData.append(\"size\", size);\n        user && formData.append(\"user\", user);\n        const response = await this.fetcher(IMAGE_VARIATIONS_API_URL, {\n            method: \"POST\",\n            body: formData,\n            headers: {\n                Authorization: `Bearer ${this.openaiApiKey}`,\n            },\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        const { data } = await response.json();\n        const images = data.map((d) => d.url || d.b64_json);\n        return { images };\n    }\n    async voiceChat(options) {\n        const { transcribeAudioUrl, transcribeLanguage, transcribePrompt } = options;\n        const { text } = await this.transcribe({\n            audioUrl: transcribeAudioUrl,\n            language: transcribeLanguage,\n            prompt: transcribePrompt,\n        });\n        const { chatMessages, chatTemplate, chatInputs } = options;\n        const messages = [...(chatMessages || []), { role: \"user\", content: text }];\n        const chatResult = await this.chat({\n            messages,\n            template: chatTemplate,\n            inputs: chatInputs,\n        });\n        const { choices } = chatResult;\n        const { speakModelId, speechVoideId, speechVoiceSettings } = options;\n        const { audioUrl } = await this.speak({\n            text: choices[0].message.content,\n            model_id: speakModelId,\n            voice_id: speechVoideId,\n            voice_settings: speechVoiceSettings,\n        });\n        return {\n            audioUrl,\n            messages: [\n                { role: \"user\", content: text },\n                { role: \"assistant\", content: choices[0].message.content },\n            ],\n        };\n    }\n    async callReplicate(options) {\n        const { version, input, timeout = 10000 } = options;\n        if (!input) {\n            throw makeErrorResponse(\"'input' is required\", 400);\n        }\n        // Create Prediction Model\n        const createPredictionResponse = await this.fetcher(REPLICATE_API_URL, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Token ${this.replicateApiKey}`,\n            },\n            body: JSON.stringify({\n                version: version,\n                input: input,\n            }),\n        });\n        if (!createPredictionResponse.ok) {\n            throw makeErrorResponse(await createPredictionResponse.text());\n        }\n        const { id: prediction_id } = await createPredictionResponse.json();\n        const GET_PREDICTION_URL = REPLICATE_API_URL + \"/\" + prediction_id;\n        // Wait for 10 seconds(by default) to run the model\n        const sleep = async (milliseconds) => {\n            await new Promise((resolve) => {\n                return setTimeout(resolve, milliseconds);\n            });\n        };\n        await sleep(timeout);\n        const statusResponse = await this.fetcher(GET_PREDICTION_URL, {\n            method: \"GET\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Token ${this.replicateApiKey}`,\n            },\n        });\n        if (!statusResponse.ok) {\n            throw new Error(await statusResponse.text());\n        }\n        const getResponse = await statusResponse.json();\n        if (getResponse && getResponse.status === \"succeeded\") {\n            return {\n                id: getResponse.id,\n                urls: getResponse.urls,\n                status: getResponse.status,\n                output: getResponse.output,\n                metrics: getResponse.metrics,\n            };\n        }\n        else {\n            return {\n                output: \"Training Not Completed! Please increase the value of timeout and try again.\",\n            };\n        }\n    }\n    async callHuggingFace(options) {\n        const { data, model } = options;\n        /* data can be a object with input as the required key or\n        a string represneting a binary file path, the binary file can then\n        be converted to binary format and passed to data\n        */\n        const link = HUGGING_FACE_API_URL + model;\n        const response = await this.fetcher(link, {\n            method: \"POST\",\n            headers: { Authourization: `Bearer ${this.huggingFaceApiKey}` },\n            body: JSON.stringify(data),\n        });\n        if (!response.ok) {\n            throw makeErrorResponse(await response.text());\n        }\n        const result = await response.json();\n        return result;\n    }\n}\nexport function createLLMService(options = {}) {\n    return new LLMService(options);\n}\n", "\"use client\";\nimport { useContext, useRef } from \"react\";\nimport { streamOpenAIResponse, cosineSimilarity, scoreEmbeddings, } from \"../shared/utils\";\nimport { LLMContext } from \"./llm-provider\";\nexport default function useLLM({ serviceUrl: argServiceUrl, fetcher = fetch, } = {}) {\n    const { serviceUrl: contextServiceUrl } = useContext(LLMContext);\n    const serviceUrl = argServiceUrl || contextServiceUrl || \"\";\n    if (!serviceUrl) {\n        throw new Error(\"No serviceUrl provided. Provide one or use LLMProvider to set it globally.\");\n    }\n    async function chat({ messages = [], stream = false, template, inputs, onStream, }) {\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                messages,\n                stream,\n                $action: \"chat\",\n                template,\n                inputs,\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        if (stream) {\n            return streamOpenAIResponse(response, onStream);\n        }\n        else {\n            const resJson = await response.json();\n            const message = resJson.choices[0].message;\n            return { message };\n        }\n    }\n    const recordingRef = useRef(null);\n    async function record({ deviceId } = {}) {\n        const audioStream = await navigator.mediaDevices.getUserMedia({\n            audio: deviceId ? { deviceId } : true,\n        });\n        const mediaRecorder = new MediaRecorder(audioStream);\n        const audioChunks = [];\n        recordingRef.current = { mediaRecorder, audioChunks, audioStream };\n        mediaRecorder.addEventListener(\"dataavailable\", (event) => {\n            audioChunks.push(event.data);\n        });\n        mediaRecorder.start();\n    }\n    async function stopRecording() {\n        return new Promise((resolve, reject) => {\n            if (!recordingRef.current) {\n                reject(\"No recording in progress\");\n                return;\n            }\n            const { mediaRecorder, audioChunks, audioStream } = recordingRef.current;\n            mediaRecorder.addEventListener(\"stop\", () => {\n                const audioBlob = new Blob(audioChunks, {\n                    type: \"audio/ogg; codecs=opus\",\n                });\n                const reader = new FileReader();\n                reader.onloadend = () => {\n                    const base64data = reader.result;\n                    resolve({ audioUrl: base64data });\n                };\n                reader.readAsDataURL(audioBlob);\n            });\n            mediaRecorder.stop();\n            audioStream.getTracks().forEach((track) => track.stop());\n        });\n    }\n    async function transcribe({ audioUrl, language, prompt, }) {\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                audioUrl,\n                language,\n                prompt,\n                $action: \"transcribe\",\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function embed({ input, user }) {\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                input,\n                user,\n                $action: \"embed\",\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function speak(options) {\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(Object.assign(Object.assign({}, options), { $action: \"speak\" })),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function generateImage(options) {\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(Object.assign(Object.assign({}, options), { $action: \"generateImage\" })),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function editImage(options) {\n        const { imageUrl, maskUrl, prompt, n, size } = options;\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                prompt,\n                n,\n                size,\n                image: imageUrl,\n                mask: maskUrl,\n                $action: \"editImage\",\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function imageVariation(options) {\n        const { imageUrl, n, size } = options;\n        const response = await fetcher(`${serviceUrl}`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                image: imageUrl,\n                n: n,\n                size: size,\n                $action: \"imageVariation\",\n            }),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function fileToDataURL(file) {\n        return new Promise((resolve, reject) => {\n            const reader = new FileReader();\n            reader.onloadend = () => resolve(reader.result);\n            reader.onerror = reject;\n            reader.readAsDataURL(file);\n        });\n    }\n    async function imageToDataURL(file) {\n        return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.src = URL.createObjectURL(file);\n            img.onload = () => {\n                const canvas = document.createElement(\"canvas\");\n                canvas.width = img.width;\n                canvas.height = img.height;\n                const ctx = canvas.getContext(\"2d\");\n                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, 0, 0, img.width, img.height);\n                const dataUrl = canvas.toDataURL(\"image/png\");\n                resolve(dataUrl);\n            };\n            img.onerror = reject;\n        });\n    }\n    async function voiceChat(options) {\n        return callAction(\"voiceChat\", options);\n    }\n    async function callAction(action, options) {\n        const response = await fetcher(serviceUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify(Object.assign(Object.assign({}, options), { $action: action })),\n        });\n        if (!response.ok) {\n            throw new Error(await response.text());\n        }\n        return response.json();\n    }\n    async function callReplicate(options) {\n        return callAction(\"callReplicate\", options);\n    }\n    async function callHuggingFace(options) {\n        return callAction(\"callHuggingFace\", options);\n    }\n    return {\n        callAction,\n        chat,\n        voiceChat,\n        record,\n        stopRecording,\n        transcribe,\n        embed,\n        cosineSimilarity,\n        scoreEmbeddings,\n        speak,\n        generateImage,\n        fileToDataURL,\n        imageToDataURL,\n        editImage,\n        imageVariation,\n        callReplicate,\n        callHuggingFace,\n    };\n}\n", "\"use client\";\nimport { createContext, createElement } from \"react\";\nexport const LLMContext = createContext({});\nexport function LLMProvider({ children, serviceUrl, }) {\n    return createElement(LLMContext.Provider, { value: { serviceUrl } }, children);\n}\n", "import { createLLMService } from \"./server/llm-service\";\nimport useLLM from \"./client/usellm\";\nimport { LLMProvider } from \"./client/llm-provider\";\nexport default useLLM;\nexport { createLLMService, LLMProvider };\n"],
  "mappings": "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",
  "names": ["message", "v", "import_react"]
}
